# Рефлексия по реализации методов в LinkedList2_2

## 9. Метод, который "переворачивает" связный список.

В отличие от рекомендации, которая предлагает пробегать по всему списку и в заключение не забыть поменять head и tail, я поменял head и tail **в начале** метода, а не в конце. Это позволяет итерироваться с нового head (бывшего tail) вперёд по полю `next`, которое после замены ссылок указывает на предыдущий узел.

## 10. Проверка, имеются ли циклы внутри списка.

Рекомендация предлагает простой подход: цикл for по элементам до длины списка, и если конечным узлом не будет хвост, значит в списке есть цикл.

Я выбрал другой подход — **алгоритм Флойда** (медленный и быстрый указатели).

### Недостатки моего подхода
- Менее очевиден: нужно понимать, почему два указателя с разной скоростью обязательно встретятся в цикле
- Рекомендация проще для понимания: если после n шагов не дошли до tail — есть цикл

## 11. Сортировка списка.

Сортировка пузырьком проще, но сортировка слиянием эффективнее на больших данных. Для учебных целей пузырёк действительно нагляднее.

## 12. Слияние списков.

Моя реализация корректна для двух списков, но не обобщена на произвольное количество.

## 13. Dummy.

Рекомендация предупреждает: *"Нередкая ошибка - добавлять в dummy отдельный флажок"*. Я последовал этому совету:
- Создал отдельный класс `DummyNode extends Node`
- Не добавлял никаких флагов в основной класс `Node`
- Проверка идёт по сравнению с dummyHead/dummyTail

В итоге Dummy-узлы устраняют специальные случаи, код становится выразительнее. Круговая структура с одним dummy-узлом более элегантна, но два узла проще для понимания и отладки.

